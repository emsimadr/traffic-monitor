<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibrate - Traffic Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #video-wrap {
            position: relative;
            width: 100%;
        }
        #video-feed {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: block;
        }
        #overlay {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
    </style>
</head>
<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4">
        <div class="container">
            <a class="navbar-brand" href="/">Traffic Monitor</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/calibrate">Calibrate</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/config">Configuration</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row g-3">
            <div class="col-lg-8">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Click to set counting line</h5>
                        <span class="badge bg-secondary" id="line-status">Click P1</span>
                    </div>
                    <div class="card-body">
                        <div id="video-wrap">
                            <img src="/video_feed" id="video-feed" alt="Video Stream">
                            <canvas id="overlay"></canvas>
                        </div>
                        <div class="text-muted small mt-2">
                            Tip: line is stored as ratios (0..1). Click 2 points (P1 then P2). Use Reset to try again.
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-lg-4">
                <div class="card mb-3">
                    <div class="card-header">
                        <h6 class="mb-0">Image calibration</h6>
                    </div>
                    <div class="card-body">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="swap-rb">
                            <label class="form-check-label" for="swap-rb">Swap R/B (fix weird colors)</label>
                        </div>

                        <div class="mt-3">
                            <label class="form-label" for="rotate">Rotate</label>
                            <select class="form-select" id="rotate">
                                <option value="0">0째</option>
                                <option value="90">90째</option>
                                <option value="180">180째</option>
                                <option value="270">270째</option>
                            </select>
                        </div>

                        <div class="form-check mt-3">
                            <input class="form-check-input" type="checkbox" id="flip-h">
                            <label class="form-check-label" for="flip-h">Flip horizontal</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="flip-v">
                            <label class="form-check-label" for="flip-v">Flip vertical</label>
                        </div>

                        <hr />

                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-secondary" id="reset-line">Reset line</button>
                            <button class="btn btn-primary" id="save">Save</button>
                        </div>
                        <div class="text-muted small mt-2">
                            Saving persists to <code>config.yaml</code>. Counting line changes apply immediately; camera changes may require restart.
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h6 class="mb-0">Current values</h6>
                    </div>
                    <div class="card-body">
                        <pre class="mb-0 small" id="debug"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const img = document.getElementById('video-feed');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('line-status');
        const debugEl = document.getElementById('debug');

        let p1 = null; // {xRatio, yRatio}
        let p2 = null;
        let existingLine = null;

        function canvasSizeToImage() {
            const rect = img.getBoundingClientRect();
            canvas.width = Math.max(1, Math.floor(rect.width));
            canvas.height = Math.max(1, Math.floor(rect.height));
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const drawPoint = (p, color) => {
                const x = p.xRatio * canvas.width;
                const y = p.yRatio * canvas.height;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
            };

            const drawLine = (a, b, color) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(a.xRatio * canvas.width, a.yRatio * canvas.height);
                ctx.lineTo(b.xRatio * canvas.width, b.yRatio * canvas.height);
                ctx.stroke();
            };

            if (existingLine && (!p1 && !p2)) {
                drawLine(existingLine[0], existingLine[1], 'rgba(255,255,0,0.85)');
            }

            if (p1) drawPoint(p1, 'rgba(0,255,0,0.9)');
            if (p2) {
                drawPoint(p2, 'rgba(0,255,0,0.9)');
                drawLine(p1, p2, 'rgba(0,255,0,0.9)');
            }
        }

        function setStatus() {
            if (!p1) statusEl.innerText = "Click P1";
            else if (!p2) statusEl.innerText = "Click P2";
            else statusEl.innerText = "Line ready";
        }

        function ratiosFromEvent(ev) {
            const rect = canvas.getBoundingClientRect();
            const x = (ev.clientX - rect.left) / rect.width;
            const y = (ev.clientY - rect.top) / rect.height;
            return {
                xRatio: Math.max(0, Math.min(1, x)),
                yRatio: Math.max(0, Math.min(1, y)),
            };
        }

        canvas.addEventListener('click', (ev) => {
            const p = ratiosFromEvent(ev);
            if (!p1) p1 = p;
            else p2 = p;
            setStatus();
            draw();
            updateDebug();
        });

        function updateDebug() {
            const cam = {
                swap_rb: document.getElementById('swap-rb').checked,
                rotate: parseInt(document.getElementById('rotate').value || '0'),
                flip_horizontal: document.getElementById('flip-h').checked,
                flip_vertical: document.getElementById('flip-v').checked,
            };
            const det = {
                counting_line: (p1 && p2) ? [[p1.xRatio, p1.yRatio], [p2.xRatio, p2.yRatio]] : null,
            };
            debugEl.innerText = JSON.stringify({camera: cam, detection: det}, null, 2);
        }

        async function loadCalibration() {
            const res = await fetch('/api/calibration');
            const data = await res.json();

            document.getElementById('swap-rb').checked = !!(data.camera && data.camera.swap_rb);
            document.getElementById('rotate').value = String((data.camera && data.camera.rotate) || 0);
            document.getElementById('flip-h').checked = !!(data.camera && data.camera.flip_horizontal);
            document.getElementById('flip-v').checked = !!(data.camera && data.camera.flip_vertical);

            if (data.detection && Array.isArray(data.detection.counting_line) && data.detection.counting_line.length === 2) {
                existingLine = [
                    {xRatio: data.detection.counting_line[0][0], yRatio: data.detection.counting_line[0][1]},
                    {xRatio: data.detection.counting_line[1][0], yRatio: data.detection.counting_line[1][1]},
                ];
            } else {
                existingLine = null;
            }

            updateDebug();
            setStatus();
            draw();
        }

        async function saveCalibration() {
            const payload = {
                camera: {
                    swap_rb: document.getElementById('swap-rb').checked,
                    rotate: parseInt(document.getElementById('rotate').value || '0'),
                    flip_horizontal: document.getElementById('flip-h').checked,
                    flip_vertical: document.getElementById('flip-v').checked,
                },
                detection: {
                    counting_line: (p1 && p2) ? [[p1.xRatio, p1.yRatio], [p2.xRatio, p2.yRatio]] : null,
                }
            };

            const res = await fetch('/api/calibration', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload),
            });
            const data = await res.json();
            if (!data.success) {
                alert('Failed to save: ' + (data.error || 'unknown error'));
                return;
            }
            // Make the saved line become the "existing line" and reset current selection
            if (payload.detection.counting_line) {
                existingLine = [
                    {xRatio: payload.detection.counting_line[0][0], yRatio: payload.detection.counting_line[0][1]},
                    {xRatio: payload.detection.counting_line[1][0], yRatio: payload.detection.counting_line[1][1]},
                ];
            }
            p1 = null;
            p2 = null;
            setStatus();
            draw();
            updateDebug();
        }

        document.getElementById('reset-line').addEventListener('click', () => {
            p1 = null;
            p2 = null;
            setStatus();
            draw();
            updateDebug();
        });

        document.getElementById('save').addEventListener('click', saveCalibration);
        document.getElementById('swap-rb').addEventListener('change', updateDebug);
        document.getElementById('rotate').addEventListener('change', updateDebug);
        document.getElementById('flip-h').addEventListener('change', updateDebug);
        document.getElementById('flip-v').addEventListener('change', updateDebug);

        window.addEventListener('resize', () => {
            canvasSizeToImage();
            draw();
        });

        // When the <img> first loads enough layout info, size the canvas
        img.addEventListener('load', () => {
            canvasSizeToImage();
            draw();
        });

        // Initial
        canvasSizeToImage();
        loadCalibration();
        setInterval(draw, 500); // keep overlay aligned even if layout shifts
    </script>
</body>
</html>


